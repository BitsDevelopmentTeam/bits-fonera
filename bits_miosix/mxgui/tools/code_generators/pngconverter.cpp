/***************************************************************************
 *   Copyright (C) 2010, 2011 by Terraneo Federico                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, see <http://www.gnu.org/licenses/>   *
 ***************************************************************************/

/*
 * pngconverter.cpp
 * convert a png image into a .cpp file to be used with mxgui.
 * number of bit per pixel of output image can be configured as 8, 16, 18 or 24.
 */

#include <iostream>
#include <stdexcept>
#include <string>
#include "libs/png++/png.hpp"
#include <boost/program_options.hpp>

using namespace std;
using namespace png;
using namespace boost::program_options;

/**
 * \param an unsigned short
 * \return the same short forced into little endian representation
 */
unsigned short toLittleEndian(unsigned short x)
{
	static bool first=true, little;
	union {
		unsigned short a;
		unsigned char b[2];
	} endian;
	if(first)
	{
		endian.a=0x12;
		little=endian.b[0]==0x12;
		first=false;
	}
	if(little) return x;
	endian.a=x;
	swap(endian.b[0],endian.b[1]);
	return endian.a;
}

static string toUpper(const string& x)
{
    string result(x);
    for(int i=0;i<result.length();i++) result[i]=toupper(result[i]);
    return result;
}

int main(int argc, char *argv[])
{
    //Check args
    options_description desc("PngConverter utility v1.21\n"
        "Designed by TFT : Terraneo Federico Technologies\nOptions");
    desc.add_options()
        ("help", "Prints this.")
        ("in", value<string>(), "Input png file (required)")
        ("depth", value<int>(), "Color depth, 1,8,16,18 or 24 bits (required)")
        ("out", value<string>(), "Output png file for validation")
        ("binary", "Generate a binary file instead of a .cpp/.h file")
    ;

    variables_map vm;
    store(parse_command_line(argc,argv,desc),vm);
    notify(vm);

    if(vm.count("help") || (!vm.count("in")) || (!vm.count("depth")))
    {
        cerr<<desc<<endl;
        return 1;
    }
    
    //Load image
    image<rgb_pixel> img(vm["in"].as<string>());
    cout<<"Loaded image \""<<vm["in"].as<string>()<<"\". Info:"<<endl;
    cout<<"Height  = "<<img.get_height()<<endl;
    cout<<"Width   = "<<img.get_width()<<endl;

    int pixDepth=vm["depth"].as<int>();
    int maxPixPerLine;//Used to print a limited number of pixel per line
    switch(pixDepth)
    {
        case 1:
            maxPixPerLine=16;
            break;
        case 8:
            maxPixPerLine=16;
            break;
        case 16:
            maxPixPerLine=8;
            break;
        case 18:
            maxPixPerLine=6;
            break;
        case 24:
            maxPixPerLine=6;
            break;
        default:
            throw(runtime_error("Unsupported pixel depth (not 1,8,16,18,24)"));
    }

    /*
     * Get output filemane from input filename
     * Example: if in is "/home/mypng.png"
     * filename        is "mypng"
     * path            is "/home/"
     * cppFilename     is "/home/mypng.cpp"
     * hFilename       is "/home/mypng.h"
     */
    string path="";
    string filename=vm["in"].as<string>();
    //Remove path
    size_t lastSlash=filename.find_last_of('/');
    if(lastSlash!=string::npos)
    {
        path=filename.substr(0,lastSlash+1);
        filename=filename.substr(lastSlash+1,filename.length());
    }
    //Remove extension
    filename=filename.substr(0,filename.find('.'));
    string cppFilename=path+filename+".cpp";
    string hFilename=path+filename+".h";

    //Convert image, step 1 (make .cpp file)
    const bool binary=vm.count("binary");
    ofstream file(binary ? filename.c_str() : cppFilename.c_str(),ios::binary);
    if(!file.good())
        throw(runtime_error(string("Can't open file: ")+cppFilename));

    bool outRequested=false;
    image<rgb_pixel> outImage;
    if(vm.count("out"))
    {
        outRequested=true;
        outImage=image<rgb_pixel>(img.get_width(),img.get_height());
    }
 
    if(binary==false)
    {
        file<<endl<<"//This file has been automatcally generated by "
                "pngconverter utility"<<endl<<"//Please do not edit"<<endl
                <<"#include \""<<filename<<".h\""<<endl<<endl
                <<"using namespace mxgui;"<<endl<<endl
                <<"static const short int height="<<img.get_height()<<';'<<endl
                <<"static const short int width ="<<img.get_width()<<';'<<endl
                <<endl;
        //Optimization for 16 bit per pixel
        if(pixDepth==16) 
            file<<"static const unsigned short pixelData[]={"<<endl<<' ';
        else file<<"static const unsigned char pixelData[]={"<<endl<<' ';
    } else {
        unsigned short header[3];
        header[0]=toLittleEndian((unsigned short)img.get_height());
        header[1]=toLittleEndian((unsigned short)img.get_width());
        header[2]=toLittleEndian((unsigned short)pixDepth);
        file.write(reinterpret_cast<char*>(&header),sizeof(header));
    }

    int numPerLine=0;//Number of pixel per line. when reaches limit, wrap
    for(int y=0;y<img.get_height();y++)
    {
        for(int x=0;x<img.get_width();x++)
        {
            rgb_pixel pix=img.get_pixel(x,y);
            unsigned int i;
            unsigned char c;
            unsigned short s;
            unsigned int r,g,b;
            switch(pixDepth)
            {
                case 1:
                    throw(runtime_error("Implement me"));
                    break;
                case 8:
                    r=pix.red & (7<<5);
                    g=pix.green & (7<<5);
                    b=pix.blue & (3<<6);
                    i=r | g>>3 | b>>6;
                    if(binary)
                    {
                        c=(unsigned char)i;
                        file.write(reinterpret_cast<char*>(&c),1);
                    } else file<<i;
                    if(outRequested) outImage.set_pixel(x,y,rgb_pixel(r,g,b));
                    break;
                case 16:
                    r=(pix.red & (31<<3))>>3;
                    g=(pix.green & (63<<2))>>2;
                    b=(pix.blue & (31<<3))>>3;
                    i=(r<<(5+6) | g<<5 | b);
                    if(binary)
                    {
                        s=toLittleEndian((unsigned short)i);
                        file.write(reinterpret_cast<char*>(&s),2);
                    } else file<<i;
                    if(outRequested) outImage.set_pixel(x,y,rgb_pixel(r,g,b));
                    break;
                case 18:
                    throw(runtime_error("Implement me"));
                    r=pix.red & 0xfc;
                    g=pix.green & 0xfc;
                    b=pix.blue & 0xfc;
                    file<<(r>>2)<<','<<(g>>2)<<','<<(b>>2);
                    if(outRequested) outImage.set_pixel(x,y,rgb_pixel(r,g,b));
                    break;
                case 24:
                    throw(runtime_error("Implement me"));
                    file<<(int)(pix.red)<<','
                        <<(int)(pix.green)<<','
                        <<(int)(pix.blue);
                    if(outRequested) outImage.set_pixel(x,y,pix);
                    break;
            }
            if(binary) continue;
            if((x==img.get_width()-1)&&(y==img.get_height()-1))
            {
                //It's the last pixel, so do not print ','
            } else {
                file<<',';
                if(++numPerLine==maxPixPerLine)
                {
                    numPerLine=0;
                    file<<endl<<' ';
                }
            }
        }
    }
    if(!binary) file<<endl<<"};"<<endl<<endl<<"const Image "<<filename
            <<"(height,width,pixelData);";
    file.close();

    if(outRequested) outImage.write(vm["out"].as<string>());

    //Convert image, step 2 (make .h file)
    if(binary) return 0;
    file.open(hFilename.c_str());
    if(!file.good())
        throw(runtime_error(string("Can't open file: ")+hFilename));
    
    file<<endl<<"//This file has been automatcally generated by "
            "pngconverter utility"<<endl<<"//Please do not edit"<<endl
            <<"#ifndef "<<toUpper(filename)<<"_H"<<endl
            <<"#define "<<toUpper(filename)<<"_H"<<endl<<endl
            <<"#include \"mxgui/image.h\""<<endl<<endl
            <<"extern const mxgui::Image "<<filename<<";"<<endl<<endl
            <<"#endif //"<<toUpper(filename)<<"_H"<<endl;
    file.close();
    return 0;
}
