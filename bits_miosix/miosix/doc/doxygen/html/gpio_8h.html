<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Miosix: gpio.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>gpio.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;interfaces-impl/gpio_impl.h&quot;</code><br/>
<table class="memberdecls">
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The interface to gpios provided by Miosix is in the form of templates, therefore this file can only include gpio_impl.h with the architecture dependand code.</p>
<p>The interface should be as follows: First a class Mode containing an enum Mode_ needs to be defined. Its minimum implementation is this: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>Mode
 {
 <span class="keyword">public</span>:
     <span class="keyword">enum</span> Mode_
     {
         INPUT,
         OUTPUT
     };
 <span class="keyword">private</span>:
     Mode(); <span class="comment">//Just a wrapper class, disallow creating instances</span>
 };
</pre></div><p>This class should define the possible configurations of a gpio pin. The minimum required is INPUT and OUTPUT, but this can be extended to other options to reflect the hardware capabilities of gpios. For example, if gpios can be set as input with pull up, it is possible to add INPUT_PULL_UP to the enum.</p>
<p>Then a template Gpio class should be provided, with at least the following member functions: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> P, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> N&gt;
 <span class="keyword">class </span>Gpio
 {
 <span class="keyword">public</span>:
     <span class="keyword">static</span> <span class="keywordtype">void</span> mode(Mode::Mode_ m);
     <span class="keyword">static</span> <span class="keywordtype">void</span> high();
     <span class="keyword">static</span> <span class="keywordtype">void</span> low();
     <span class="keyword">static</span> <span class="keywordtype">int</span> value();
 <span class="keyword">private</span>:
     Gpio();<span class="comment">//Only static member functions, disallow creating instances</span>
 };
</pre></div><p>mode() should take a Mode::Mode_ enum and set the mode of the gpio (input, output or other architecture specific)</p>
<p>high() should set a gpio configured as output to high logic level</p>
<p>low() should set a gpio configured as output to low logic level</p>
<p>value() should return either 1 or 0 to refect the state of a gpio configured as input</p>
<p>Lastly, a number of constants must be provided to be passed as first template parameter of the Gpio class, usually identifying the gpio port, while the second template parameter should be used to specify a gpio pin within a port.</p>
<p>The intended use is this: considering an architecture with two ports, PORTA and PORTB each with 8 pins. The header gpio_impl.h should provide two constants, for example named GPIOA_BASE and GPIOB_BASE.</p>
<p>The user can declare the hardware mapping between gpios and what is connected to them, usually in an header file. If for example PORTA.0 is connected to a button while PORTB.4 to a led, the header file might contain:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> Gpio&lt;GPIOA_BASE,0&gt; button;
 <span class="keyword">typedef</span> Gpio&lt;GPIOB_BASE,4&gt; led;
</pre></div><p>This allows the rest of the code to be written in terms of leds and buttons, without a reference to which pin they are connected to, something that might change.</p>
<p>A simple code using these gpios could be: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> blinkUntilButtonPressed()
 {
     led::mode(Mode::OUTPUT);
     button::mode(Mode::INPUT);
     <span class="keywordflow">for</span>(;;)
     {
         <span class="keywordflow">if</span>(button::value()==1) <span class="keywordflow">break</span>;
         led::high();
         Thread::sleep(250);
         led::low();
         Thread::sleep(250);
     }
 }
</pre></div> </div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Nov 12 2011 for Miosix by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
