<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Miosix: miosix::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacemiosix.html">miosix</a>      </li>
      <li><a class="el" href="classmiosix_1_1_thread.html">miosix::Thread</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>miosix::Thread Class Reference<br/>
<small>
[<a class="el" href="group___kernel.html">Kernel</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="miosix::Thread" -->
<p><code>#include &lt;kernel.h&gt;</code></p>

<p><a href="classmiosix_1_1_thread-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daaf">Options</a> { <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e">DEFAULT</a> = 0, 
<a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7">JOINABLE</a> = 1&lt;&lt;0
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#aacba6298a092d5335f6dbefe56a611ec">getPriority</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ae086b5bf2b3b55972ad696ec820c8f5e">terminate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a88af678dc4032a5f92da12917947d881">PKwakeup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ae7817dd59f317a04d3ce3793419d25a4">detach</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#afb1d97df689c7104bec35858bbaf4ae6">isDetached</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a968b43a36ecdf124d72a5d8ddfa2a3b9">join</a> (void **<a class="el" href="classmiosix_1_1_thread.html#a448486b757b8ede4edaa8edc39962b17">result</a>=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a585c7966f59855aafd771c7733a38296">IRQgetPriority</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ab34c3cbac8aa609a5c6e4abc384a9faa">IRQwakeup</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ac5a454f2617a4a28f00842b1097fc363">create</a> (void *(*startfunc)(void *), unsigned int stacksize, <a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a> priority=<a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>(), void *argv=NULL, unsigned short options=DEFAULT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a12d19634d30226cb4441a77b233a5bf2">create</a> (void(*startfunc)(void *), unsigned int stacksize, <a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a> priority=<a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>(), void *argv=NULL, unsigned short options=DEFAULT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a75823b1288a7defcb715fd6591a23b2d">yield</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a0ef492878827009d2d55442266d13b99">testTerminate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ad7f738dc69a918960fe814a062696c5c">sleep</a> (unsigned int ms)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#aac116a322826366c7b3269db3ab4be73">sleepUntil</a> (long long absoluteTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a884bfd106afeb274c339d383702b4aec">getCurrentThread</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#adb06c8f5761db66d1089a61db71dcf92">exists</a> (<a class="el" href="classmiosix_1_1_thread.html">Thread</a> *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#af6c4237506c533c00a0144632685b17d">setPriority</a> (<a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a> pr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a435fe4527c1fdfcbebf886cd748a3fd4">wait</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#ae3918e86d91bbe3062f907004ba7f579">IRQgetCurrentThread</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a6aed14f0f04e69f922aba8f0cf7ac0c6">IRQwait</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmiosix_1_1_thread.html#a572b87e4c6174ad4137f964e40bbe515">IRQexists</a> (<a class="el" href="classmiosix_1_1_thread.html">Thread</a> *p)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class represents a thread. It has methods for creating, deleting and handling threads.<br/>
It has private constructor and destructor, since memory for a thread is handled by the kernel.<br/>
To create a thread use the static producer method <a class="el" href="classmiosix_1_1_thread.html#ac5a454f2617a4a28f00842b1097fc363">create()</a>.<br/>
 Methods that have an effect on the current thread, that is, the thread that is calling the method are static.<br/>
 Calls to non static methods must be done with care, because a thread can terminate at any time. For example, if you call <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a> on a terminated thread, the behavior is undefined. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="acaef68f0e93f6ad933442d87c210daaf"></a><!-- doxytag: member="miosix::Thread::Options" ref="acaef68f0e93f6ad933442d87c210daaf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daaf">miosix::Thread::Options</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classmiosix_1_1_thread.html">Thread</a> options, can be passed to <a class="el" href="classmiosix_1_1_thread.html#ac5a454f2617a4a28f00842b1097fc363">Thread::create</a> to set additional options of the thread. More options can be specified simultaneously by ORing them together. The DEFAULT option indicates the default thread creation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e"></a><!-- doxytag: member="DEFAULT" ref="acaef68f0e93f6ad933442d87c210daafa03df086cf889e215d75222d10486b71e" args="" -->DEFAULT</em>&nbsp;</td><td>
<p>Default thread options. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7"></a><!-- doxytag: member="JOINABLE" ref="acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7" args="" -->JOINABLE</em>&nbsp;</td><td>
<p><a class="el" href="classmiosix_1_1_thread.html">Thread</a> is joinable instead of detached. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac5a454f2617a4a28f00842b1097fc363"></a><!-- doxytag: member="miosix::Thread::create" ref="ac5a454f2617a4a28f00842b1097fc363" args="(void *(*startfunc)(void *), unsigned int stacksize, Priority priority=Priority(), void *argv=NULL, unsigned short options=DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::create </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>startfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em> = <code><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>argv</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Producer method, creates a new thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startfunc</em>&nbsp;</td><td>the entry point function for the thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stacksize</em>&nbsp;</td><td>size of thread stack, its minimum is the constant STACK_MIN. The size of the stack must be divisible by 4, otherwise it will be rounded to a number divisible by 4. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>the thread's priority, between 0 (lower) and PRIORITY_MAX-1 (higher) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>a void* pointer that is passed as pararmeter to the entry point function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>thread options, such ad <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7" title="Thread is joinable instead of detached.">Thread::JOINABLE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the thread created, that can be used, for example, to delete it, or NULL in case of errors.</dd></dl>
<p>Calls errorHandler(INVALID_PARAMETERS) if stacksize or priority are invalid, and errorHandler(OUT_OF_MEMORY) if the heap is full. Can be called when the kernel is paused. Note: this is the only method of this class that can be called BEFORE the kernel is started. </p>

</div>
</div>
<a class="anchor" id="a12d19634d30226cb4441a77b233a5bf2"></a><!-- doxytag: member="miosix::Thread::create" ref="a12d19634d30226cb4441a77b233a5bf2" args="(void(*startfunc)(void *), unsigned int stacksize, Priority priority=Priority(), void *argv=NULL, unsigned short options=DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::create </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>startfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em> = <code><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>argv</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code>DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as create(void (*startfunc)(void *), unsigned int stacksize, Priority priority=1, void *argv=NULL) but in this case the entry point of the thread returns a void* </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startfunc</em>&nbsp;</td><td>the entry point function for the thread </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stacksize</em>&nbsp;</td><td>size of thread stack, its minimum is the constant STACK_MIN. The size of the stack must be divisible by 4, otherwise it will be rounded to a number divisible by 4. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>the thread's priority, between 0 (lower) and PRIORITY_MAX-1 (higher) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>a void* pointer that is passed as pararmeter to the entry point function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>thread options, such ad <a class="el" href="classmiosix_1_1_thread.html#acaef68f0e93f6ad933442d87c210daafa785d69b0e6b95b648735efe54b588df7" title="Thread is joinable instead of detached.">Thread::JOINABLE</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the thread created, that can be used, for example, to delete it, or NULL in case of errors. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7817dd59f317a04d3ce3793419d25a4"></a><!-- doxytag: member="miosix::Thread::detach" ref="ae7817dd59f317a04d3ce3793419d25a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::detach </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Detach the thread if it was joinable, otherwise do nothing.<br/>
 If called on a deleted joinable thread on which join was not yet called, it allows the thread's memory to be deallocated.<br/>
 If called on a thread that is not yet deleted, the call detaches the thread without deleting it. If called on an already detached thread, it has undefined behaviour. </p>

</div>
</div>
<a class="anchor" id="adb06c8f5761db66d1089a61db71dcf92"></a><!-- doxytag: member="miosix::Thread::exists" ref="adb06c8f5761db66d1089a61db71dcf92" args="(Thread *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a thread exists </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>thread to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if thread exists, false if does not exist or has been deleted. A joinable thread is considered existing until it has been joined, even if it returns from its entry point (unless it is detached and terminates).</dd></dl>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a884bfd106afeb274c339d383702b4aec"></a><!-- doxytag: member="miosix::Thread::getCurrentThread" ref="a884bfd106afeb274c339d383702b4aec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::getCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the <a class="el" href="classmiosix_1_1_thread.html">Thread</a> class of the current thread. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the current thread.</dd></dl>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="aacba6298a092d5335f6dbefe56a611ec"></a><!-- doxytag: member="miosix::Thread::getPriority" ref="aacba6298a092d5335f6dbefe56a611ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a> miosix::Thread::getPriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the priority of a thread.<br/>
 To get the priority of the current thread use: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classmiosix_1_1_thread.html#a884bfd106afeb274c339d383702b4aec">Thread::getCurrentThread</a>()-&gt;getPriority(); 
</pre></div><p> If the thread is currently locking one or more mutexes, this member function returns the current priority, which can be higher than the original priority due to priority inheritance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current priority of the thread</dd></dl>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a572b87e4c6174ad4137f964e40bbe515"></a><!-- doxytag: member="miosix::Thread::IRQexists" ref="a572b87e4c6174ad4137f964e40bbe515" args="(Thread *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::IRQexists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#adb06c8f5761db66d1089a61db71dcf92">exists()</a> but is meant to be called only inside an IRQ or when interrupts are disabled. </p>

</div>
</div>
<a class="anchor" id="ae3918e86d91bbe3062f907004ba7f579"></a><!-- doxytag: member="miosix::Thread::IRQgetCurrentThread" ref="ae3918e86d91bbe3062f907004ba7f579" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_thread.html">Thread</a> * miosix::Thread::IRQgetCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as get_current_thread(), but meant to be used insida an IRQ, when interrupts are disabled or when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a585c7966f59855aafd771c7733a38296"></a><!-- doxytag: member="miosix::Thread::IRQgetPriority" ref="a585c7966f59855aafd771c7733a38296" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a> miosix::Thread::IRQgetPriority </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#aacba6298a092d5335f6dbefe56a611ec">getPriority()</a>, but meant to be used inside an IRQ, when interrupts are disabled or when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a6aed14f0f04e69f922aba8f0cf7ac0c6"></a><!-- doxytag: member="miosix::Thread::IRQwait" ref="a6aed14f0f04e69f922aba8f0cf7ac0c6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::IRQwait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#a435fe4527c1fdfcbebf886cd748a3fd4">wait()</a>, but is meant to be used only inside an IRQ or when interrupts are disabled.<br/>
 Note: this method is meant to put the current thread in wait status in a piece of code where interrupts are disbled; it returns immediately, so the user is responsible for re-enabling interrupts and calling yield to effectively put the thread in wait status.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group___kernel.html#gacd7ef6e968c5c0b2ff45bf102388ea4d">disableInterrupts</a>();
 ...
 <a class="code" href="classmiosix_1_1_thread.html#a6aed14f0f04e69f922aba8f0cf7ac0c6">Thread::IRQwait</a>();<span class="comment">//Return immediately</span>
 <a class="code" href="group___kernel.html#ga36adaaa176d004747d2a01b822c9fea5">enableInterrupts</a>();
 <a class="code" href="classmiosix_1_1_thread.html#a75823b1288a7defcb715fd6591a23b2d">Thread::yield</a>();<span class="comment">//After this, thread is in wait status</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ab34c3cbac8aa609a5c6e4abc384a9faa"></a><!-- doxytag: member="miosix::Thread::IRQwakeup" ref="ab34c3cbac8aa609a5c6e4abc384a9faa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::IRQwakeup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same as <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a>, but is meant to be used only inside an IRQ or when interrupts are disabled. </p>

</div>
</div>
<a class="anchor" id="afb1d97df689c7104bec35858bbaf4ae6"></a><!-- doxytag: member="miosix::Thread::isDetached" ref="afb1d97df689c7104bec35858bbaf4ae6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::isDetached </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the thread is detached </dd></dl>

</div>
</div>
<a class="anchor" id="a968b43a36ecdf124d72a5d8ddfa2a3b9"></a><!-- doxytag: member="miosix::Thread::join" ref="a968b43a36ecdf124d72a5d8ddfa2a3b9" args="(void **result=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::join </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>result</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait until a joinable thread is terminated.<br/>
 If the thread already terminated, this function returns immediately.<br/>
 Calling <a class="el" href="classmiosix_1_1_thread.html#a968b43a36ecdf124d72a5d8ddfa2a3b9">join()</a> on the same thread multiple times, from the same or multiple threads is not recomended, but in the current implementation the first call will wait for join, and the other will return false.<br/>
 Trying to join the thread join is called in returns false, but must be avoided.<br/>
 Calling join on a detached thread might cause undefined behaviour. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>If the entry point function of the thread to join returns void *, the return value of the entry point is stored here, otherwise the content of this variable is undefined. If NULL is passed as result the return value will not be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a88af678dc4032a5f92da12917947d881"></a><!-- doxytag: member="miosix::Thread::PKwakeup" ref="a88af678dc4032a5f92da12917947d881" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::PKwakeup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wakeup a thread. <br/>
Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="af6c4237506c533c00a0144632685b17d"></a><!-- doxytag: member="miosix::Thread::setPriority" ref="af6c4237506c533c00a0144632685b17d" args="(Priority pr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmiosix_1_1_priority_scheduler_priority.html">Priority</a>&nbsp;</td>
          <td class="paramname"> <em>pr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the priority of this thread.<br/>
 This member function changed from previous Miosix versions since it is now static. This implies a thread can no longer set the priority of another thread. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pr</em>&nbsp;</td><td>desired priority. Must be 0&lt;=pr&lt;PRIORITY_MAX</td></tr>
  </table>
  </dd>
</dl>
<p>Calls errorHandler(INVALID_PARAMETERS) if pr is not within bounds.</p>
<p>Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="ad7f738dc69a918960fe814a062696c5c"></a><!-- doxytag: member="miosix::Thread::sleep" ref="ad7f738dc69a918960fe814a062696c5c" args="(unsigned int ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>ms</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the thread to sleep for a number of milliseconds.<br/>
The actual precision depends on the kernel tick used. If the specified wait time is lower than the tick accuracy, the thread will be put to sleep for one tick.<br/>
Maximum sleep time is (2^32-1) / TICK_FREQ. If a sleep time higher than that value is specified, the behaviour is undefined. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ms</em>&nbsp;</td><td>the number of millisecond. If it is ==0 this method will return immediately</td></tr>
  </table>
  </dd>
</dl>
<p>CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="aac116a322826366c7b3269db3ab4be73"></a><!-- doxytag: member="miosix::Thread::sleepUntil" ref="aac116a322826366c7b3269db3ab4be73" args="(long long absoluteTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>absoluteTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the thread to sleep until the specified absolute time is reached. If the time is in the past, returns immediately. To make a periodic thread, this is the recomended way </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> periodicThread()
 {
     <span class="comment">//Run every 90 milliseconds</span>
     <span class="keyword">const</span> <span class="keywordtype">int</span> period=<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(TICK_FREQ*0.09);
     <span class="keywordtype">long</span> <span class="keywordtype">long</span> tick=<a class="code" href="group___kernel.html#gad16c495ced6659e8bc0bb371362674ef">getTick</a>();
     <span class="keywordflow">for</span>(;;)
     {
         <span class="comment">//Do work</span>
         tick+=period;
         <a class="code" href="classmiosix_1_1_thread.html#aac116a322826366c7b3269db3ab4be73">Thread::sleepUntil</a>(tick);
     }
 }
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>absoluteTime</em>&nbsp;</td><td>when to wake up</td></tr>
  </table>
  </dd>
</dl>
<p>CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="ae086b5bf2b3b55972ad696ec820c8f5e"></a><!-- doxytag: member="miosix::Thread::terminate" ref="ae086b5bf2b3b55972ad696ec820c8f5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::terminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suggests a thread to terminate itself. Note that this method only makes <a class="el" href="classmiosix_1_1_thread.html#a0ef492878827009d2d55442266d13b99">testTerminate()</a> return true on the specified thread. If the thread does not call <a class="el" href="classmiosix_1_1_thread.html#a0ef492878827009d2d55442266d13b99">testTerminate()</a>, or if it calls it but does not delete itself by returning from entry point function, it will NEVER terminate. The user is responsible for implementing correctly this functionality.<br/>
<a class="el" href="classmiosix_1_1_thread.html">Thread</a> termination is implemented like this to give time to a thread to deallocate resources, close files... before terminating. <br/>
Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a0ef492878827009d2d55442266d13b99"></a><!-- doxytag: member="miosix::Thread::testTerminate" ref="a0ef492878827009d2d55442266d13b99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool miosix::Thread::testTerminate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method needs to be called periodically inside the thread's main loop. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if somebody outside the thread called <a class="el" href="classmiosix_1_1_thread.html#ae086b5bf2b3b55972ad696ec820c8f5e">terminate()</a> on this thread.</dd></dl>
<p>If it returns true the thread must free all resources and terminate by returning from its main function. <br/>
Can be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a435fe4527c1fdfcbebf886cd748a3fd4"></a><!-- doxytag: member="miosix::Thread::wait" ref="a435fe4527c1fdfcbebf886cd748a3fd4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::wait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method stops the thread until another thread calls <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a> on this thread.<br/>
Calls to wait are not cumulative. If <a class="el" href="classmiosix_1_1_thread.html#a435fe4527c1fdfcbebf886cd748a3fd4">wait()</a> is called two times, only one call to <a class="el" href="classmiosix_1_1_thread.html#af19b8a2ab852ea771a2e2b95bb0ba2a8">wakeup()</a> is needed to wake the thread. <br/>
CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="af19b8a2ab852ea771a2e2b95bb0ba2a8"></a><!-- doxytag: member="miosix::Thread::wakeup" ref="af19b8a2ab852ea771a2e2b95bb0ba2a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::wakeup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wakeup a thread. <br/>
CANNOT be called when the kernel is paused. </p>

</div>
</div>
<a class="anchor" id="a75823b1288a7defcb715fd6591a23b2d"></a><!-- doxytag: member="miosix::Thread::yield" ref="a75823b1288a7defcb715fd6591a23b2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void miosix::Thread::yield </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When called, suggests the kernel to pause the current thread, and run another one. <br/>
CANNOT be called when the kernel is paused. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>kernel.h</li>
<li>kernel.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Nov 12 2011 for Miosix by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
